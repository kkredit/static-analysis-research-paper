%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SETUP %
\documentclass[journal]{IEEEtran}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\def\tt#1{\mbox{\texttt{#1}}}

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TITLE %

\title{FlawFinder and Secure Development Processes}

\author{\IEEEauthorblockN{Kevin Kredit}
\IEEEauthorblockA{\textit{GVSU CIS Department} \\
Grand Rapids, Michigan \\
Email: k.kredit.us@ieee.org}
}

\maketitle


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ABSTRACT %

\begin{abstract}
Static analysis tools provide insights to security and correctness early in the software development
process. FlawFinder is a static analysis tool for C and C++ focusing on dangerous method use. It
performs a syntax-aware search, identifies dangerous functions uses, and prints a ranked list of
warnings. A complete secure development process may employ multiple static analysis tools. Statick
is a plugin-based framework to manage multiple tools, including FlawFinder. To simplify the workflow
for small projects, a Docker container has been built with a portable Statick environment.
\end{abstract}

\begin{IEEEkeywords}
FlawFinder, Statick, static analysis, secure software, development process
\end{IEEEkeywords}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PAPER %

\section{Introduction}

Security cannot be bolted on. The sooner project developers consider security, the cheaper it is to
achieve. If a project can continuously validate application security principles before it is
finished, or even before it builds, it will experience fewer costly surprises later on.

Static analysis tools provide this continuous validation capability. They read source code and
report possible errors in a developer-friendly format. Other validation techniques such as
functional tests, unit tests, binary analysis, and runtime analysis require varying levels of
readiness. Because static analysis tools require only source code, developers can integrate them
from the beginning of the process.

FlawFinder is a static analysis tool for C and C++ \cite{flawfinder}. It works by searching for
invocations of dangerous or hard to use functions, ranking them based in order of risk, and
displaying them with helpful messages.

This paper gives a brief overview of static analysis tools in general, including their purpose,
their capabilities and limitations, and how they fit in a secure software engineering workflow. It
then describes FlawFinder in particular, including how it works, how it is configured, and example
output from running it against a real project. Finally, it strives to lower the barrier for static
analysis tool usage by describing the Statick framework and introducing a project that provides the
Statick environment in a portable Docker container.


\section{Static Analysis Tools}

Static analysis tools read source code files and produce warnings related to incorrect or dangerous
constructs. Because they do not compile or execute code, there are limitations on what types of
errors they can detect. Therefore, they comprise only a part of a complete secure software
development process.

\subsection{Capabilities}

Analyzing source code provides several capabilities.

\paragraph{Analyze during development} As already established, considering security late in the
development process is difficult and costly. A major advantage of static analysis tools is that they
do not require a complete product to test; they do not even require code to compile or contain valid
syntax. Teams can setup static analysis tools at the start of a project and reap the benefits from
the first line of code.

\paragraph{Correct little human errors} Humans make frequent trivial errors. By negligence or
ignorance, developers make typos and violate coding standards. Working with editors and compilers,
source code analysis tools can identify and correct spelling errors and enforce coding standard
rules.

\paragraph{Identify dangerous method usage} Many standard software libraries contain dangerous or
difficult to use methods. For example, the C standard library's \tt{strcpy} is highly vulnerable to
buffer overflows, and the safer \tt{strncpy} should be used instead. \tt{strcpy} cannot be removed
from the library for the sake of backwards compatibility. To prevent its use in new code, static
analysis tools can detect such usage.

\paragraph{Identify dangerous syntax idioms} Sometimes syntactic features that lead to concise code
can also lead to confusion, and confusion leads to errors. Static analysis can identify these
dangerous idioms.

\paragraph{Apply rigorous logical analysis} Beyond some of the simple applications, advanced static
analysis can detect errors that would take a human a long time to identify. Through control or data
flow analysis, it can detect dead code, memory errors, and information leakage. This type of
advanced analysis is typically computationally expensive and limited by the semantics of the
language under analysis (e.g., the rules of Rust enable stronger static guarantees than C).

\subsection{Limitations}

Analyzing source alone also entails limitations.

\paragraph{No functional testing} Source code analysis is not intelligent to tell whether code is
semantically correct. Functional tests are still necessary to ensure correct feature implementation.

\paragraph{No compiler validation} A fully verified toolchain requires certification that the
compiled assembly code correctly implements the uncompiled source. Functional testing informally
tests this; static analysis cannot.

\paragraph{No higher order logic validation} Many security vulnerabilities are the result of
insecure designs, not insecure implementations. Algorithm, protocol, and architecture analysis are
not within the scope of static analysis tools.

\subsection{Secure Software Development Process}


\section{FlawFinder}

\subsection{Purpose}

\subsection{How It Works}

\subsection{Example}


\section{Easy Static Analysis}

\subsection{Lower the Barrier to Entry}

\subsection{Frameworks}

\subsection{Docker Container}


\section{Conclusion}
Conclusion.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% BIBLIOGRAPHY %

\begin{thebibliography}{00}

\bibitem{flawfinder} D. Wheeler, "Flawfinder Home Page", Dwheeler.com, 2019. [Online]. Available:
https://dwheeler.com/flawfinder/. [Accessed: 02- Nov- 2019].

\bibitem{statick} "sscpac/statick", GitHub, 2019. [Online]. Available:
https://github.com/sscpac/statick. [Accessed: 02- Nov- 2019].

\end{thebibliography}


\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% REFERENCE %

% \begin{equation}
% a+b=\gamma\label{eq}
% \end{equation}

% \paragraph{A labeled paragraph} With some text.

% \begin{table}[htbp]
% \caption{Table Type Styles}
% \begin{center}
% \begin{tabular}{|c|c|c|c|}
% \hline
% \textbf{Table}&\multicolumn{3}{|c|}{\textbf{Table Column Head}} \\
% \cline{2-4}
% \textbf{Head} & \textbf{\textit{Table column subhead}}& \textbf{\textit{Subhead}}&
%\textbf{\textit{Subhead}} \\
% \hline
% copy& More table copy$^{\mathrm{a}}$& &  \\
% \hline
% \multicolumn{4}{l}{$^{\mathrm{a}}$Sample of a Table footnote.}
% \end{tabular}
% \label{tab1}
% \end{center}
% \end{table}

% \begin{figure}[htbp]
% \centerline{\includegraphics{fig1.png}}
% \caption{Example of a figure caption.}
% \label{fig}
% \end{figure}

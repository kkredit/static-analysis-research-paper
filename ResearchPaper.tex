%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SETUP %
\documentclass[journal]{IEEEtran}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{rotating}
\usepackage{afterpage}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\def\tt#1{\mbox{\texttt{#1}}}

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TITLE %

\title{Flawfinder and Secure Development Processes}

\author{\IEEEauthorblockN{Kevin Kredit}
\IEEEauthorblockA{\textit{GVSU CIS Department} \\
Grand Rapids, Michigan \\
Email: k.kredit.us@ieee.org}
}

\maketitle


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ABSTRACT %

\begin{abstract}
Static analysis tools provide insights to security and correctness early in the software development
process. Flawfinder is a static analysis tool for C and C++ focusing on dangerous method use. It
performs a syntax-aware search, identifies dangerous functions uses, and prints a ranked list of
warnings. A complete secure development process may employ multiple static analysis tools. Statick
is a plugin-based framework to manage multiple tools, including Flawfinder. To simplify the workflow
for small projects, a Docker container has been built with a portable Statick environment.
\end{abstract}

\begin{IEEEkeywords}
Flawfinder, Statick, static analysis, secure software, development process
\end{IEEEkeywords}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PAPER %

\section{Introduction}

Security cannot be bolted on. The sooner project developers consider security, the cheaper it is to
achieve. If a project can continuously validate application security principles before it is
finished, or even before it builds, it will experience fewer costly surprises later on.

Static analysis tools provide this continuous validation capability. They read source code and
report possible errors in a developer-friendly format. Other validation techniques such as
functional tests, unit tests, binary analysis, and runtime analysis require varying levels of
readiness. Because static analysis tools require only source code, developers can integrate them
from the beginning of the process.

Flawfinder is a static analysis tool for C and C++ \cite{flawfinder}. It works by searching for
invocations of dangerous or hard to use functions, ranking them based in order of risk, and
displaying them with helpful messages.

This paper gives a brief overview of static analysis tools in general, including their purpose,
their capabilities and limitations, and how they fit in a secure software engineering workflow. It
then describes Flawfinder in particular, including how it works, how it is configured, and example
output from running it against a real project. Finally, it strives to lower the barrier for static
analysis tool usage by describing the Statick framework and introducing a project that provides the
Statick environment in a portable Docker container.


\section{Static Analysis Tools}

Static analysis tools read source code files and produce warnings related to incorrect or dangerous
constructs. Because they do not compile or execute code, there are limitations on what types of
errors they can detect. Therefore, they comprise only a part of a complete secure software
development process.

\subsection{Capabilities}

Analyzing source code provides several capabilities.

\paragraph{Analyze during development} As already established, considering security late in the
development process is difficult and costly. A major advantage of static analysis tools is that they
do not require a complete product to test; they do not even require code to compile or contain valid
syntax. Teams can setup static analysis tools at the start of a project and reap the benefits from
the first line of code.

\paragraph{Correct little human errors} Humans make frequent trivial errors. By negligence or
ignorance, developers make typos and violate coding standards. Working with editors and compilers,
source code analysis tools can identify and correct spelling errors and enforce coding standard
rules.

\paragraph{Identify dangerous method usage} Many standard software libraries contain dangerous or
difficult to use methods. For example, the C standard library's \tt{strcpy} is highly vulnerable to
buffer overflows, and the safer \tt{strncpy} should be used instead. \tt{strcpy} cannot be removed
from the library for the sake of backwards compatibility. To prevent its use in new code, static
analysis tools can detect such usage.

\paragraph{Identify dangerous syntax idioms} Sometimes syntactic features that lead to concise code
can also lead to confusion, and confusion leads to errors. Static analysis can identify these
dangerous idioms.

\paragraph{Apply rigorous logical analysis} Beyond some of the simple applications, advanced static
analysis can detect errors that would take a human a long time to identify. Through control or data
flow analysis, it can detect dead code, memory errors, and information leakage. This type of
advanced analysis is typically computationally expensive and limited by the semantics of the
language under analysis (e.g., the rules of Rust enable stronger static guarantees than C).

\subsection{Limitations}

Analyzing source alone also entails limitations.

\paragraph{No functional testing} Source code analysis is not intelligent to tell whether code is
semantically correct. Functional tests are still necessary to ensure correct feature implementation.

\paragraph{No compiler validation} A fully verified toolchain requires certification that the
compiled assembly code correctly implements the uncompiled source. Functional testing informally
tests this; static analysis cannot.

\paragraph{No higher order logic validation} Many security vulnerabilities are the result of
insecure designs, not insecure implementations. Algorithm, protocol, and architecture analysis are
not within the scope of static analysis tools.

\subsection{Secure Software Development Process}

See figure \ref{fig:ms_sdl}.

\afterpage{\clearpage}
\begin{sidewaysfigure}[ht]
\centerline{\includegraphics[width=1.1\linewidth,height=1.1\textheight,keepaspectratio]{images/microsoft_sdl_process.png}}
\caption{The Microsoft Software Development Lifecycle Process \cite{ms_sdl}}
\label{fig:ms_sdl}
\end{sidewaysfigure}


\section{Flawfinder}

The above section discusses static analysis tools in general. This section analyzes one such tool,
Flawfinder.

\subsection{Purpose}

Flawfinder is a free and open source C/C++ static analysis tool licensed under the GNU Public
License version 2. The project is defined by simplicity. It is simple in concept, simple in
implementation, and simple to use.

Flawfinder focuses on just one of static analysis tools' capabilities listed above--to identify
dangerous method usage \cite{flawfinder}. C and C++ standard libraries contain many functions with
potential security vulnerabilities. The languages are memory unsafe and do not enforce robust error
handling. Further, they are used in many security-critical operating system settings. Flawfinder's
simple, core purpose is to identify usage of these dangerous methods, rank each instance's risk, and
present an ordered list of potential vulnerabilities to the developer. This is its entire function.

Flawfinder is also simple in implementation. Though it analyzes C and C++, it is written in Python.
Python is a more expressive language with more powerful string parsing capabilities than C or C++.
Python is not as performant as C or C++, but at 45,000 lines/second on 2014 hardware, it is as fast
as it needs to be. Lastly, Python has a mature environment of libraries and developers, which means
that the runtime is present by default on most machines and future generations can take over
development when David Wheeler, the project's main author, no longer personally maintains the
project.

\subsection{How It Works}

\subsection{Example}


\section{Easy Static Analysis}

\subsection{Lower the Barrier to Entry}

\subsection{Frameworks}

\subsection{Docker Container}


\section{Conclusion}
Conclusion.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% BIBLIOGRAPHY %

\begin{thebibliography}{00}

\bibitem{flawfinder} D. Wheeler, "Flawfinder Home Page", \textit{Dwheeler.com}, 2019. [Online].
Available: https://dwheeler.com/Flawfinder/. [Accessed: 02- Nov- 2019].

\bibitem{statick} "sscpac/statick", \textit{GitHub}, 2019. [Online]. Available:
https://github.com/sscpac/statick. [Accessed: 02- Nov- 2019].

\bibitem{ms_sdl} "Simplified Implementation of the Microsoft SDL", \textit{Microsoft.com}, 2010.
[Online]. Available: https://www.microsoft.com/en-us/download/details.aspx?id=12379. [Accessed: 13-
Nov- 2019].

\end{thebibliography}


\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% REFERENCE %

% \begin{equation}
% a+b=\gamma\label{eq}
% \end{equation}

% \paragraph{A labeled paragraph} With some text.

% \begin{table}[htbp]
% \caption{Table Type Styles}
% \begin{center}
% \begin{tabular}{|c|c|c|c|}
% \hline
% \textbf{Table}&\multicolumn{3}{|c|}{\textbf{Table Column Head}} \\
% \cline{2-4}
% \textbf{Head} & \textbf{\textit{Table column subhead}}& \textbf{\textit{Subhead}}&
%\textbf{\textit{Subhead}} \\
% \hline
% copy& More table copy$^{\mathrm{a}}$& &  \\
% \hline
% \multicolumn{4}{l}{$^{\mathrm{a}}$Sample of a Table footnote.}
% \end{tabular}
% \label{tab1}
% \end{center}
% \end{table}

% \begin{figure}[htbp]
% \centerline{\includegraphics{fig1.png}}
% \caption{Example of a figure caption.}
% \label{fig}
% \end{figure}
